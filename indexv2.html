<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Agravity - WeatherX</title>
  <style>
    :root{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;}
    body{max-width:900px;margin:40px auto;padding:20px;line-height:1.5;color:#111}
    h1{font-size:20px;margin-bottom:8px}
    .controls{display:flex;gap:12px;align-items:center;margin-bottom:18px}
    button.primary{background:#0366d6;color:#fff;border:0;padding:10px 14px;border-radius:8px;cursor:pointer}
    button.secondary{background:#f3f4f6;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
    select{padding:10px;border-radius:8px;border:1px solid #ddd;min-width:240px}
    .card{background:#fff;border:1px solid #eee;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(16,24,40,0.04)}
    .fields{margin-top:14px;display:grid;gap:10px}
    .field-row{display:flex;align-items:center;gap:8px}
    .label{min-width:140px;font-weight:600;color:#333}
    .value{flex:1;padding:8px 12px;border-radius:8px;border:1px solid #eee;background:#fafafa;font-family:monospace}
    .copy-btn{background:transparent;border:0;padding:6px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center}
    .copy-btn svg{width:18px;height:18px;opacity:0.85}
    .status{margin-top:12px;font-size:14px;color:#444}
    .hint{margin-top:10px;color:#666;font-size:13px}
    .small{font-size:13px;color:#666}
    .maps-list{margin:6px 0 0 0;padding-left:20px}
    .maps-list li{margin:4px 0}
    .diag{margin-top:10px;font-size:13px;color:#b00}
    .section{margin-top:20px}
    .subcard{background:#fbfbfb;border:1px solid #f0f0f0;padding:12px;border-radius:8px}
    footer{margin-top:26px;color:#666;font-size:13px}
  </style>
</head>
<body>
  <h1>Agravity - WeatherX</h1>

  <div class="card">
    <div class="controls">
      <button id="downloadBtn" class="primary">Download latest</button>
      <select id="nameSelect">
        <option value="">-- Select name --</option>
      </select>
      <button id="refreshBtn" class="secondary">Refresh dropdown</button>
    </div>

    <div class="small">Selected point details</div>
    <div id="fieldsArea" class="fields"></div>
    <div id="mapsArea" style="margin-top:8px"></div>
    <div id="copiedStatus" class="status">Copied: <strong id="copiedText">None</strong></div>
    <div id="diag" class="diag" aria-live="polite"></div>
  </div>

  <!-- New section: Find Weather -->
  <div class="section">
    <div class="card subcard">
      <div class="small">Find Weather</div>
      <div style="display:flex;gap:12px;align-items:center;margin-top:10px">
        <select id="mapsSelect">
          <option value="">-- Select map string --</option>
        </select>
        <div id="mapToName" style="font-weight:600">Weather name: <span id="mapNameDisplay">None</span></div>
      </div>
      <div style="margin-top:8px;color:#666;font-size:13px">Select any map to see its weather location.</div>
    </div>
  </div>



  <script>
    // CONFIG: set your public JSON URL here
    const JSON_URL = 'weather_locations.json'; // replace

    let latestData = null; // array of points
    let mapToNameIndex = {}; // map string -> array of names (in case duplicates)

    const downloadBtn = document.getElementById('downloadBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const selectEl = document.getElementById('nameSelect');
    const mapsSelectEl = document.getElementById('mapsSelect');
    const fieldsArea = document.getElementById('fieldsArea');
    const mapsArea = document.getElementById('mapsArea');
    const copiedTextEl = document.getElementById('copiedText');
    const diagEl = document.getElementById('diag');
    const mapNameDisplay = document.getElementById('mapNameDisplay');

    function setDiag(msg, isError=false){ diagEl.textContent = msg; diagEl.style.color = isError ? '#b00' : '#444'; }

    function formatNum(n){
      return typeof n === 'number' ? n.toFixed(10) : (isNaN(Number(n)) ? n : Number(n).toFixed(10));
    }

    async function fetchJson(url){
      const sep = url.includes('?') ? '&' : '?';
      const fetchUrl = `${url}${sep}_=${Date.now()}`;
      console.info('[fetchJson] requesting:', fetchUrl);

      const res = await fetch(fetchUrl, {
        method: 'GET', mode: 'cors', cache: 'no-store', credentials: 'omit',
        headers: { 'Pragma': 'no-cache', 'Cache-Control': 'no-cache, no-store, must-revalidate' }
      });

      console.info('[fetchJson] status:', res.status);
      const hdrs = ['cache-control','etag','last-modified','age','cf-cache-status','x-cache','via','server'];
      hdrs.forEach(h => { const v = res.headers.get(h); if (v) console.info(`[fetchJson] header ${h}:`, v); });

      if (!res.ok) throw new Error('Fetch failed: ' + res.status + ' ' + res.statusText);
      return await res.json();
    }

    function extractPoints(data){
      if (!data) return [];
      if (Array.isArray(data)) return data;
      if (Array.isArray(data.days)) return data.days;
      for (const k of ['points','items','data']) if (Array.isArray(data[k])) return data[k];
      const numericKeys = Object.keys(data).filter(x => !isNaN(Number(x))).sort((a,b)=>a-b);
      if (numericKeys.length) return numericKeys.map(k=>data[k]);
      return [];
    }

    // builds mapToNameIndex and returns sorted unique map strings
    function buildMapIndex(points){
      mapToNameIndex = {};
      const set = new Set();
      points.forEach(p => {
        const name = p.name || '';
        const mapsKey = Object.keys(p).find(k => k.toLowerCase() === 'maps');
        if (!mapsKey) return;
        const val = p[mapsKey];
        if (Array.isArray(val)){
          val.forEach(s => { if (s!==null && s!==undefined) { const str = String(s); set.add(str); if (!mapToNameIndex[str]) mapToNameIndex[str] = []; mapToNameIndex[str].push(name); } });
        } else if (typeof val === 'string'){
          const str = val; set.add(str); if (!mapToNameIndex[str]) mapToNameIndex[str] = []; mapToNameIndex[str].push(name);
        }
      });
      // return sorted array (case-insensitive)
      return Array.from(set).sort((a,b)=>a.toLowerCase().localeCompare(b.toLowerCase()));
    }

    function loadIntoDropdown(points){
      // sort points by name (case-insensitive)
      const sorted = [...points].sort((a,b)=>{
        const na = (a.name||'').toLowerCase(); const nb = (b.name||'').toLowerCase();
        return na.localeCompare(nb);
      });

      latestData = sorted;
      selectEl.innerHTML = '<option value="">-- Select name --</option>';
      if (!sorted || sorted.length === 0){ const opt = document.createElement('option'); opt.textContent = 'No points found'; selectEl.appendChild(opt); return; }
      sorted.forEach((p,i)=>{ const opt=document.createElement('option'); opt.value=i; opt.textContent=p.name||('point_'+i); selectEl.appendChild(opt); });

      // build maps index and populate mapsSelect
      const mapsList = buildMapIndex(sorted);
      populateMapsSelect(mapsList);

      // setDiag(`Loaded ${sorted.length} points from live source.`);
    }

    function populateMapsSelect(mapsList){
      mapsSelectEl.innerHTML = '<option value="">-- Select map --</option>';
      if (!mapsList || mapsList.length===0){ const opt=document.createElement('option'); opt.textContent='No maps found'; mapsSelectEl.appendChild(opt); return; }
      mapsList.forEach((s,i)=>{ const opt=document.createElement('option'); opt.value=s; opt.textContent=s; mapsSelectEl.appendChild(opt); });
    }

    function clearFields(){ fieldsArea.innerHTML = ''; mapsArea.innerHTML = ''; }

    function makeCopyButton(){ const btn=document.createElement('button'); btn.type='button'; btn.className='copy-btn'; btn.title='Copy value'; btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16 21H8a2 2 0 0 1-2-2V7" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/><rect x="8" y="3" width="13" height="13" rx="2" stroke="currentColor" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/></svg>'; return btn; }

    function showFieldsForIndex(i){
      clearFields();
      if (!latestData || !latestData[i]) return;
      const p = latestData[i];

      const ordered = ['name','lat','lon','altitude','height anamoly','height_anomaly','heightAnomaly','height_anom','height'];
      const used = new Set();

      function addRow(label, rawValue, allowCopy=true){
        const row = document.createElement('div'); row.className='field-row';
        const lab = document.createElement('div'); lab.className='label'; lab.textContent = label;
        const val = document.createElement('div'); val.className='value'; val.textContent = rawValue;
        row.appendChild(lab); row.appendChild(val);
        if (allowCopy){ const copyBtn = makeCopyButton(); copyBtn.addEventListener('click', async ()=>{ try{ await navigator.clipboard.writeText(String(rawValue)); copiedTextEl.textContent = `${p.name ?? 'unknown'} : ${label}`; setDiag('Copied to clipboard: ' + (p.name ?? 'unknown') + ' : ' + label); }catch(e){ alert('Copy failed: ' + (e && e.message)); } }); row.appendChild(copyBtn); }
        fieldsArea.appendChild(row);
      }

      for (const k of ordered){
        for (const pk of Object.keys(p)){
          if (used.has(pk)) continue;
          if (pk.toLowerCase() === k.toLowerCase()){
            used.add(pk);
            const raw = (typeof p[pk] === 'number') ? formatNum(p[pk]) : p[pk];
            const allowCopy = pk.toLowerCase() !== 'name';
            addRow(pk, raw, allowCopy);
          }
        }
      }

      for (const pk of Object.keys(p)){
        if (used.has(pk)) continue; used.add(pk);
        if (pk.toLowerCase() === 'maps') continue;
        const raw = (typeof p[pk] === 'number') ? formatNum(p[pk]) : p[pk];
        const allowCopy = pk.toLowerCase() !== 'name';
        addRow(pk, raw, allowCopy);
      }

      const mapsKey = Object.keys(p).find(k => k.toLowerCase() === 'maps');
      if (mapsKey){
        const mapsVal = p[mapsKey];
        const containerLabel = document.createElement('div'); containerLabel.className='label'; containerLabel.textContent='maps';
        const ul = document.createElement('ul'); ul.className = 'maps-list';
        if (Array.isArray(mapsVal)){
          mapsVal.forEach(item => { const li = document.createElement('li'); li.textContent = String(item); ul.appendChild(li); });
        } else if (typeof mapsVal === 'string'){
          const li = document.createElement('li'); li.textContent = mapsVal; ul.appendChild(li);
        }
        mapsArea.appendChild(containerLabel);
        mapsArea.appendChild(ul);
      }
    }

    // event listeners
    downloadBtn.addEventListener('click', async ()=>{ try{ downloadBtn.disabled=true; downloadBtn.textContent='Downloading...'; const data = await fetchJson(JSON_URL); const points = extractPoints(data); loadIntoDropdown(points); setDiag('Downloaded latest data.'); }catch(err){ alert('Error: ' + err.message); setDiag('Download failed: ' + err.message, true); console.error(err); }finally{ downloadBtn.disabled=false; downloadBtn.textContent='Download latest'; } });

    refreshBtn.addEventListener('click', async ()=>{ try{ refreshBtn.disabled=true; refreshBtn.textContent='Refreshing...'; const data = await fetchJson(JSON_URL); loadIntoDropdown(extractPoints(data)); }catch(err){ alert('Error: ' + err.message); setDiag('Refresh failed: ' + err.message, true); console.error(err);}finally{ refreshBtn.disabled=false; refreshBtn.textContent='Refresh dropdown'; } });

    selectEl.addEventListener('change', (ev)=>{ const val = ev.target.value; if (val === ''){ clearFields(); return; } showFieldsForIndex(Number(val)); });

    // maps select: show first matching name (there could be multiple names for same map string)
    mapsSelectEl.addEventListener('change', (ev)=>{
      const val = ev.target.value;
      if (!val){ mapNameDisplay.textContent = 'None'; return; }
      const names = mapToNameIndex[val] || [];
      // if multiple names mapped, show comma separated list
      mapNameDisplay.textContent = names.length ? names.join(', ') : 'None';
    });

    // init: always fetch live and do not store anything locally
    (async function init(){
      try{
        const data = await fetchJson(JSON_URL);
        const pts = extractPoints(data);
        loadIntoDropdown(pts);
      }catch(e){ console.warn('Prefetch failed', e); setDiag('Failed to fetch live JSON: ' + (e && e.message), true); }
    })();
  </script>
</body>
</html>
